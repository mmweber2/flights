import datetime
import urllib2
import json
from collections import namedtuple

def send_request(query):
    """Sends a flight query to the QPX Server.

    Using a query string from build_query, sends an HTTP request to the QPX
    server and returns the response.

    Limited to 50 queries per day.

    Args:
        query: string, JSON-formatted data generated by build_query.

    Returns:
        A string containing the JSON-formatted data of the search results.
    """
    # TODO: Error checking of query
    base_url = "https://www.googleapis.com/qpxExpress/v1/trips/search?key="
    url = base_url + _get_auth_key()
    request = urllib2.Request(url, query, 
            {'Content-Type': 'application/json', 'Content-Length': len(query)})
    flight = urllib2.urlopen(request)
    response = flight.read()
    flight.close()
    return response

Flight = namedtuple('Flight', 'price legs')
Leg = namedtuple('Leg',
    'origin destination dep_time arr_time carrier flight_no, duration')
def _parse_flights(result):
    """Converts result data from JSON string into Flight namedtuples."""
    flight_data = None
    # TODO: Change to result parameter instead of test file
    with open("sample_result.txt", "r") as sample:
        flight_data = json.loads(sample.read())
    # flight_data is a dict with unicode keys:
    # 'trips' > 'tripOption' > 'saleTotal'
    # 'trips' > 'tripOption' > 'slice' > (list of flights)
    # (list of flights) > 'segment' > 'leg' > (list of legs)
    # (list of legs) > 'departureTime', 'arrivalTime', 'origin', 'destination'
    # (list of flights) > 'segment' > 'flight' > 'carrier, 'number'
    flights = []
    for flight in flight_data[u'trips'][u'tripOption']:
        price = flight[u'saleTotal'][3:] # Crop off 'USD'
        legs = []
        for flight_slice in flight[u'slice']:
            duration = flight_slice[u'duration']
            for leg in flight_slice[u'segment']:
                carrier = leg[u'flight'][u'carrier']
                flight_no = leg[u'flight'][u'number']
                leg_data = leg[u'leg'][0]
                dep_time = leg_data[u'departureTime']
                arr_time = leg_data[u'arrivalTime']
                origin = leg_data[u'origin']
                arr_port = leg_data[u'destination']
                legs.append(Leg(origin, arr_port, dep_time, arr_time, carrier,
                    flight_no, duration))
        flights.append(Flight(price, legs))
    print flights


def _get_auth_key(path="DEFAULT"):
    """Fetches an authorization key stored elsewhere on the file system.

    This key is used for communicating with the QPX server, and is stored
    separately from the code for security reasons.

    Args:
        path: string, the full pathname (including filename) of the file
            containing the authorization key.

    Returns:
        string, the authorization key for the QPX server.
    """
    DEFAULT = "/Users/Toz/code/auth_key.txt"
    loc = DEFAULT if path == "DEFAULT" else path
    key = ""
    with open(loc, 'r') as input_file:
        key = input_file.read().strip()
    return key

def build_query(dep_port="CHI", arr_port="TYO", dep_date="2017-04-01", 
        trip_length=90, max_cost=900):
    """Builds a JSON query for checking flights on QPX."""
    # TODO: Error checking and handling
    # Line locations in the default JSON query
    DEP_LOCS = (4, 10)
    ARR_LOCS = (5, 9)
    DEP_DATE_LOC = (6,)
    RET_DATE_LOC = (11,)
    PRICE_LOC = (18,)

    with open("base_query.json", "r") as raw_file:
        query = raw_file.readlines()
    if dep_port != "CHI":
        _replace_text(query, DEP_LOCS, "CHI", dep_port)
    if arr_port != "TYO":
        _replace_text(query, ARR_LOCS, "TYO", arr_port)
    return_date = _calculate_date(dep_date, trip_length)
    if dep_date != "2017-04-01":
        _replace_text(query, DEP_DATE_LOC, "2017-04-01", dep_date)
    _replace_text(query, RET_DATE_LOC, "2017-06-30", return_date)
    if max_cost != 900:
        _replace_text(query, PRICE_LOC, "900", str(max_cost))
    return "".join(query)

def _replace_text(query, lines, old_text, new_text):
    """Replaces text in a query at the given lines."""
    for loc in lines:
        line = query[loc]
        suffix = line[line.find(old_text) + len(old_text):]
        query[loc] = line[:line.find(old_text)] + new_text + suffix
    return query

def _calculate_date(start_date, duration):
    """Calculates a return date given a start date and duration."""
    start_date = datetime.date(*map(int, start_date.split("-")))
    new_date = start_date + datetime.timedelta(duration)
    year = format(new_date.year, '04')
    month = format(new_date.month, '02')
    day = format(new_date.day, '02')
    return "-".join((year, month, day))

_parse_flights(None)
